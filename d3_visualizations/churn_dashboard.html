<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telco Customer Churn Dashboard - D3.js Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        
        .dashboard-header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 30px;
        }
        
        .dashboard-header h1 {
            font-size: 2.5em;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }
        
        .dashboard-header p {
            color: #aaa;
            margin-top: 10px;
        }
        
        .metrics-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin-bottom: 40px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px 40px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: #888;
            font-size: 0.9em;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        
        .chart-title {
            font-size: 1.2em;
            margin-bottom: 20px;
            color: #00d4ff;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            padding-bottom: 10px;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #00d4ff;
        }
        
        .axis-label {
            fill: #888;
            font-size: 12px;
        }
        
        .tick text {
            fill: #888;
        }
        
        .tick line {
            stroke: #444;
        }
        
        .domain {
            stroke: #444;
        }
        
        .legend {
            font-size: 12px;
        }
        
        .legend-item {
            cursor: pointer;
        }
        
        .bar-chart .bar {
            transition: opacity 0.3s;
        }
        
        .bar-chart .bar:hover {
            opacity: 0.8;
        }
        
        .pie-slice {
            transition: transform 0.3s;
            cursor: pointer;
        }
        
        .pie-slice:hover {
            transform: scale(1.05);
        }
        
        .footer {
            text-align: center;
            padding: 30px;
            color: #666;
            margin-top: 40px;
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <h1>üìä Telco Customer Churn Analytics</h1>
        <p>Interactive D3.js Visualization Dashboard | Big Data & Visualization Coursework</p>
    </div>
    
    <div class="metrics-container">
        <div class="metric-card">
            <div class="metric-value" style="color: #00d4ff;" id="total-customers">7,032</div>
            <div class="metric-label">Total Customers</div>
        </div>
        <div class="metric-card">
            <div class="metric-value" style="color: #ff6b6b;" id="churn-rate">26.58%</div>
            <div class="metric-label">Churn Rate</div>
        </div>
        <div class="metric-card">
            <div class="metric-value" style="color: #4ecdc4;" id="avg-revenue">$64.80</div>
            <div class="metric-label">Avg Monthly Revenue</div>
        </div>
        <div class="metric-card">
            <div class="metric-value" style="color: #ffd93d;" id="high-risk">1,869</div>
            <div class="metric-label">High Risk Customers</div>
        </div>
        <div class="metric-card" style="display:flex;flex-direction:column;gap:8px;align-items:center;justify-content:center;">
            <button id="copy-link" style="padding:6px 10px;border-radius:6px;border:none;background:#ffd93d;color:#0b1a1e;cursor:pointer;">Copy Shareable Link</button>
            <button id="reset-filters" style="padding:6px 10px;border-radius:6px;border:none;background:#4ecdc4;color:#0b1a1e;cursor:pointer;">Reset Filters</button>
        </div>
    </div>
    
    <div class="charts-grid">
        <div class="chart-container">
            <h3 class="chart-title">üìà Churn Distribution</h3>
            <div id="pie-chart"></div>
        </div>
        
        <div class="chart-container">
            <h3 class="chart-title">üìä Churn by Contract Type</h3>
            <div id="bar-chart-contract"></div>
        </div>
        
        <div class="chart-container">
            <h3 class="chart-title">üìâ Churn Rate by Tenure</h3>
            <div id="line-chart-tenure"></div>
        </div>
        
        <div class="chart-container">
            <h3 class="chart-title">üí≥ Churn by Payment Method</h3>
            <div id="bar-chart-payment"></div>
        </div>
        
        <div class="chart-container">
            <h3 class="chart-title">üåê Internet Service Impact</h3>
            <div id="donut-chart-internet"></div>
        </div>
        
        <div class="chart-container">
            <h3 class="chart-title">üìä Monthly Charges Distribution</h3>
            <div id="histogram-charges"></div>
        </div>
    </div>
    
    <div class="footer">
        <p>Student ID: E285181</p>
        <p>Data Source: Telco Customer Churn Dataset (<span id="total-records">7,032</span> records)</p>
    </div>
    
    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        // Load precomputed aggregate CSVs (exported by scripts/export_aggregates.py)
        let churnData = {};
        // Interactive filter state
        const filterState = { 
            status: null,        // 'Retained' | 'Churned' 
            contract: null,      // 'Month-to-month' | 'One year' | 'Two year'
            payment: null,       // 'Electronic check' | 'Mailed check' | 'Bank transfer (automatic)' | 'Credit card (automatic)'
            internet: null,      // 'Fiber optic' | 'DSL' | 'No'
            tenure: null,        // '0-12' | '13-24' | '25-36' | '37-48' | '49-60' | '61+'
            charges: null        // '18-30' | '31-50' | '51-70' | '71-90' | '91-110' | '111-118'
        };
        // Health gradient color scale (green ‚Üí red) by churn rate
        const healthColor = d3.scaleLinear().domain([0, 50]).range(["#28a745", "#dc3545"]).clamp(true);

        // Load aggregate CSVs AND attempt to load raw dataset for richer client-side filtering
        Promise.all([
            d3.csv("./data/churn_distribution.csv"),
            d3.csv("./data/contract_distribution.csv"),
            d3.csv("./data/tenure_buckets.csv"),
            d3.csv("./data/payment_methods.csv"),
            d3.csv("./data/internet_service.csv"),
            d3.csv("./data/monthly_charges_bins.csv"),
            d3.csv("../data/raw/Telco_Customer_Churn_Dataset.csv") // optional; used for client-side recompute/export
        ]).then(function([dist, contract, tenure, payment, internet, monthly, raw]) {
            // Map loaded CSVs to churnData structure expected by chart functions
            churnData.distribution = dist.map(d => ({ label: d.label || d.Label || d.Label, value: +d.value, color: d.color || d.Color || (d.label && d.label.toLowerCase().includes('churn') ? '#ff6b6b' : '#4ecdc4') }));

            churnData.byContract = contract.map(d => ({ contract: d.contract, churned: +d.churned, retained: +d.retained, churnRate: +d.churnRate }));

            churnData.byTenure = tenure.map(d => ({ tenure: d.tenure, customers: +d.customers, churnRate: +d.churnRate }));

            churnData.byPayment = payment.map(d => ({ method: d.method, churned: +d.churned, retained: +d.retained, churnRate: +d.churnRate }));

            churnData.byInternet = internet.map(d => ({ service: d.service, churned: +d.churned, retained: +d.retained, color: d.color || '#ffd93d' }));

            churnData.monthlyCharges = monthly.map(d => ({ range: d.range, count: +d.count, avgChurn: +d.avgChurn }));

            // Raw rows loaded? Prepare for client-side filtering and aggregations
            let rawRows = [];
            if (raw && raw.length && raw[0].customerID) {
                rawRows = raw.map(r => Object.assign({}, r));
                // Basic cleaning to mirror export_aggregates.py
                rawRows = rawRows.filter(r => String(r.TotalCharges).trim() !== "");
                rawRows.forEach(r => {
                    r.tenure = +r.tenure || 0;
                    r.MonthlyCharges = parseFloat(r.MonthlyCharges) || 0;
                    r.ChurnFlag = (String(r.Churn).trim().toLowerCase() === 'yes') ? 1 : 0;
                });
            }

            // If row-level data available, compute all aggregates from rows (enables combinational filters)
            if (rawRows.length > 0) {
                // expose raw rows globally for filter handlers
                window.__rawRows = rawRows;
                computeAggregatesFromRows(rawRows);
                updateTopMetrics(rawRows);
            }

            // Update simple top-level metrics if present
            try {
                const total = churnData.distribution.reduce((s, x) => s + x.value, 0);
                const churn = churnData.distribution.find(d => d.label && d.label.toLowerCase().includes('churn'))?.value || 0;
                // Calculate average monthly revenue from bins (approximate midpoint of each range)
                let revenueSum = 0;
                churnData.monthlyCharges.forEach(d => {
                    const parts = String(d.range).split('-').map(Number);
                    const midpoint = parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1]) ? (parts[0] + parts[1]) / 2 : 0;
                    revenueSum += midpoint * (d.count || 0);
                });
                const avgRev = total > 0 ? (revenueSum / total).toFixed(2) : '0.00';

                d3.select('#total-customers').text(total.toLocaleString());
                d3.select('#churn-rate').text(((churn/Math.max(total,1))*100).toFixed(2) + '%');
                d3.select('#avg-revenue').text('$' + avgRev);
                d3.select('#high-risk').text(churn.toLocaleString());
                d3.select('#total-records').text(total.toLocaleString());
            } catch(e) { console.warn('Metrics update skipped', e); }

            // Create all charts using current aggregates
            createPieChart();
            createContractChart();
            createTenureChart();
            createPaymentChart();
            createInternetChart();
            createChargesHistogram();

            // Wire control buttons
            d3.select('#copy-link').on('click', () => { copyShareableLink(); });
            d3.select('#reset-filters').on('click', () => { resetFilters(); });

            // Apply initial filters (none) or from URL state
            loadFiltersFromURL();
            applyFilters(false);

            console.log('Dashboard loaded from aggregate CSVs');
        }).catch(function(error) {
            console.error('Error loading aggregate CSVs:', error);
            const chartIds = ["#pie-chart", "#bar-chart-contract", "#line-chart-tenure", "#bar-chart-payment", "#donut-chart-internet", "#histogram-charges"];
            chartIds.forEach(id => {
                const container = d3.select(id);
                container.selectAll("*").remove();
                container.append("div")
                    .style("color", "#ff6b6b")
                    .style("padding", "20px")
                    .style("font-size", "14px")
                    .style("text-align", "center")
                    .html(`<strong>‚ö† Error loading aggregates</strong><br/>${error.message}<br/><small>Run scripts/export_aggregates.py to generate CSVs</small>`);
            });
        });

        // Tooltip helper
        const tooltip = d3.select("#tooltip");
        
        function showTooltip(event, content) {
            tooltip
                .style("display", "block")
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 10) + "px")
                .html(content);
        }
        
        function hideTooltip() {
            tooltip.style("display", "none");
        }
        
        // Pie chart - Churn Distribution
        function createPieChart() {
            const width = 450;
            const height = 350;
            const radius = Math.min(width, height) / 2 - 40;
            
            // Clear existing content
            d3.select("#pie-chart").selectAll("*").remove();
            
            const svg = d3.select("#pie-chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width/2}, ${height/2})`);
            
            const pie = d3.pie()
                .value(d => d.value)
                .sort(null);
            
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);
            
            const labelArc = d3.arc()
                .innerRadius(radius * 0.6)
                .outerRadius(radius * 0.6);
            
            const slices = svg.selectAll(".pie-slice")
                .data(pie(churnData.distribution))
                .enter()
                .append("g")
                .attr("class", "pie-slice");
            
            slices.append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("stroke", "#1a1a2e")
                .attr("stroke-width", 2)
                .on("mouseover", function(event, d) {
                    const total = d3.sum(churnData.distribution, d => d.value);
                    const percent = ((d.data.value / total) * 100).toFixed(1);
                    showTooltip(event, `
                        <strong>${d.data.label}</strong><br/>
                        Count: ${d.data.value.toLocaleString()}<br/>
                        Percentage: ${percent}%
                    `);
                })
                .on("mouseout", hideTooltip);
            
            slices.append("text")
                .attr("transform", d => `translate(${labelArc.centroid(d)})`)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-weight", "bold")
                .text(d => d.data.label);
            
            // Legend
            const legend = svg.selectAll(".legend-item")
                .data(churnData.distribution)
                .enter()
                .append("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(${radius + 30}, ${-20 + i * 25})`);
            
            legend.append("rect")
                .attr("width", 15)
                .attr("height", 15)
                .attr("fill", d => d.color);
            
            legend.append("text")
                .attr("x", 22)
                .attr("y", 12)
                .style("fill", "#aaa")
                .text(d => `${d.label}: ${d.value.toLocaleString()}`);
            // make slices clickable for filtering (toggle selection)
            slices.selectAll('path').on('click.filter', function(event, d) {
                toggleSelection('status', d.data.label);
                applyFilters(true);
            });
        }

        // Compute aggregates from raw rows (can be used both for initial load and after filtering)
        function computeAggregatesFromRows(rows, fromFilter=false) {
            // distribution
            const churned = rows.reduce((s, r) => s + (r.ChurnFlag || 0), 0);
            const retained = rows.length - churned;
            churnData.distribution = [
                { label: 'Retained', value: retained, color: '#4ecdc4' },
                { label: 'Churned', value: churned, color: '#ff6b6b' }
            ];

            // byContract
            const byContractMap = new Map();
            rows.forEach(r => {
                const key = r.Contract || r.contract || 'Unknown';
                if (!byContractMap.has(key)) byContractMap.set(key, { contract: key, churned: 0, retained: 0 });
                const cur = byContractMap.get(key);
                if (r.ChurnFlag) cur.churned += 1; else cur.retained += 1;
            });
            churnData.byContract = Array.from(byContractMap.values()).map(d => ({ ...d, churnRate: +(d.churned / (d.churned + d.retained) * 100).toFixed(1) }));

            // tenure buckets (use same buckets as export script)
            const buckets = [ [0,12,'0-12'], [13,24,'13-24'], [25,48,'25-48'], [49,60,'49-60'], [61,9999,'61-72'] ];
            churnData.byTenure = buckets.map(([lo,hi,label]) => {
                const sel = rows.filter(r => r.tenure >= lo && r.tenure <= hi);
                const customers = sel.length;
                const churned = sel.reduce((s, r) => s + (r.ChurnFlag||0), 0);
                const churnRate = customers>0 ? +(churned/customers*100).toFixed(1) : 0;
                return { tenure: label, customers, churnRate };
            });

            // payment methods
            const payMap = new Map();
            rows.forEach(r => { const k = r.PaymentMethod || r.method || 'Unknown'; if (!payMap.has(k)) payMap.set(k,{ method:k, churned:0, retained:0 }); const cur=payMap.get(k); if (r.ChurnFlag) cur.churned++; else cur.retained++; });
            churnData.byPayment = Array.from(payMap.values()).map(d => ({ ...d, churnRate: +(d.churned/(d.churned+d.retained)*100).toFixed(1) }));

            // internet service
            const inetMap = new Map();
            rows.forEach(r => { const k = r.InternetService || r.service || 'No'; if (!inetMap.has(k)) inetMap.set(k,{ service:k, churned:0, retained:0 }); const cur=inetMap.get(k); if (r.ChurnFlag) cur.churned++; else cur.retained++; });
            churnData.byInternet = Array.from(inetMap.values()).map(d=>({ ...d, color: (d.service && d.service.indexOf('Fiber')>-1)?'#ff6b6b':(d.service && d.service.indexOf('DSL')>-1)?'#4ecdc4':'#ffd93d', churnRate: +(d.churned/(d.churned+d.retained)*100).toFixed(1) }));

            // monthly charges bins - reuse the CSV bins if available to keep labels consistent
            const bins = churnData.monthlyCharges && churnData.monthlyCharges.length ? churnData.monthlyCharges.map(b => {
                const parts = String(b.range).split('-').map(p => parseFloat(p)); return { left: parts[0], right: parts[1], label: b.range };
            }) : null;

            if (bins) {
                const out = bins.map(b => ({ range: b.label, count: 0, avgChurn: 0 }));
                bins.forEach((b, i) => {
                    const sel = rows.filter(r => r.MonthlyCharges >= b.left && r.MonthlyCharges <= b.right);
                    const customers = sel.length;
                    const churned = sel.reduce((s, r) => s + (r.ChurnFlag||0), 0);
                    const churnRate = customers>0 ? +(churned/customers*100).toFixed(1) : 0;
                    out[i].count = customers;
                    out[i].avgChurn = churnRate;
                });
                churnData.monthlyCharges = out;
            }

            // Update top metrics if called by filter
            if (fromFilter) updateTopMetrics(rows);
        }

        // Filter raw rows by selection state (logical AND across dimensions, OR within dimension)
        function filterRows(rows) {
            return rows.filter(r => {
                // status
                if (filterState.status && filterState.status.size>0) {
                    const label = r.ChurnFlag ? 'Churned' : 'Retained';
                    if (!filterState.status.has(label)) return false;
                }
                if (filterState.contract && filterState.contract.size>0) {
                    if (!filterState.contract.has(r.Contract)) return false;
                }
                if (filterState.payment && filterState.payment.size>0) {
                    if (!filterState.payment.has(r.PaymentMethod)) return false;
                }
                if (filterState.internet && filterState.internet.size>0) {
                    if (!filterState.internet.has(r.InternetService)) return false;
                }
                if (filterState.tenure && filterState.tenure.size>0) {
                    const bucket = getTenureLabel(r.tenure);
                    if (!filterState.tenure.has(bucket)) return false;
                }
                if (filterState.charges && filterState.charges.size>0) {
                    const range = getChargeRangeLabel(r.MonthlyCharges);
                    if (!filterState.charges.has(range)) return false;
                }
                return true;
            });
        }

        function getTenureLabel(t) {
            if (t<=12) return '0-12';
            if (t<=24) return '13-24';
            if (t<=48) return '25-48';
            if (t<=60) return '49-60';
            return '61-72';
        }

        function getChargeRangeLabel(value) {
            for (const b of churnData.monthlyCharges) {
                const parts = String(b.range).split('-').map(p => parseFloat(p));
                if (value >= parts[0] && value <= parts[1]) return b.range;
            }
            return null;
        }

        function updateTopMetrics(rows) {
            const total = rows.length;
            const churn = rows.reduce((s, r) => s + (r.ChurnFlag||0), 0);
            const revenueSum = rows.reduce((s, r) => s + (parseFloat(r.MonthlyCharges)||0), 0);
            const avgRev = total>0 ? (revenueSum/total).toFixed(2) : '0.00';
            d3.select('#total-customers').text(total.toLocaleString());
            d3.select('#churn-rate').text(((churn/Math.max(total,1))*100).toFixed(2) + '%');
            d3.select('#avg-revenue').text('$' + avgRev);
            d3.select('#high-risk').text(churn.toLocaleString());
            d3.select('#total-records').text(total.toLocaleString());
        }

        // Shareable link helpers
        function updateURLFromFilters() {
            const params = new URLSearchParams();
            Object.entries(filterState).forEach(([k,v]) => { if (v && v.size) params.set(k, Array.from(v).join(',')); });
            const newUrl = window.location.pathname + '?' + params.toString();
            window.history.replaceState({}, '', newUrl);
        }

        function loadFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            for (const [k,v] of params.entries()) {
                if (!filterState[k]) filterState[k] = new Set();
                v.split(',').forEach(val => { if (val) filterState[k].add(decodeURIComponent(val)); });
            }
        }

        function copyShareableLink() {
            updateURLFromFilters();
            navigator.clipboard.writeText(window.location.href).then(()=> alert('Link copied to clipboard')); 
        }
        
        // Bar chart - Churn by Contract
        function createContractChart() {
            const margin = { top: 30, right: 30, bottom: 60, left: 60 };
            const width = 450 - margin.left - margin.right;
            const height = 320 - margin.top - margin.bottom;
            
            // Clear existing content
            d3.select("#bar-chart-contract").selectAll("*").remove();
            
            const svg = d3.select("#bar-chart-contract")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);
            
            const x = d3.scaleBand()
                .domain(churnData.byContract.map(d => d.contract))
                .range([0, width])
                .padding(0.3);
            
            // Switch to count mode if status filter active (avoids 0%/100% issue)
            const statusFilterActive = filterState.status && filterState.status.size > 0;
            const yMetric = statusFilterActive ? 'count' : 'rate';
            const maxCount = statusFilterActive ? d3.max(churnData.byContract, d => d.churned + d.retained) : 50;
            
            const y = d3.scaleLinear()
                .domain([0, statusFilterActive ? maxCount : 50])
                .range([height, 0]);
            
            // X axis
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-15)")
                .style("text-anchor", "end");
            
            // Y axis
            svg.append("g")
                .call(d3.axisLeft(y).tickFormat(d => statusFilterActive ? d : d + "%"));
            
            // Y axis label
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -45)
                .attr("x", -height / 2)
                .attr("text-anchor", "middle")
                .style("fill", "#888")
                .text(statusFilterActive ? "Customer Count" : "Churn Rate (%)");
            
            // Bars
            svg.selectAll(".bar")
                .data(churnData.byContract)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.contract))
                .attr("y", d => statusFilterActive ? y(d.churned + d.retained) : y(d.churnRate))
                .attr("width", x.bandwidth())
                .attr("height", d => statusFilterActive ? height - y(d.churned + d.retained) : height - y(d.churnRate))
                .attr("fill", d => healthColor(d.churnRate))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `
                        <strong>${d.contract}</strong><br/>
                        Churn Rate: ${d.churnRate}%<br/>
                        Churned: ${d.churned.toLocaleString()}<br/>
                        Retained: ${d.retained.toLocaleString()}
                    `);
                })
                .on("mouseout", hideTooltip)
                .on("click", function(event, d) {
                    toggleSelection('contract', d.contract);
                    applyFilters(true);
                });
            
            // Labels
            svg.selectAll(".label")
                .data(churnData.byContract)
                .enter()
                .append("text")
                .attr("x", d => x(d.contract) + x.bandwidth() / 2)
                .attr("y", d => statusFilterActive ? y(d.churned + d.retained) - 5 : y(d.churnRate) - 5)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-size", "12px")
                .text(d => statusFilterActive ? (d.churned + d.retained).toLocaleString() : d.churnRate + "%");
        }

        // Helper to toggle multi-selection (stores as Set)
        function toggleSelection(dim, value) {
            if (!filterState[dim]) filterState[dim] = new Set();
            if (filterState[dim].has(value)) filterState[dim].delete(value);
            else filterState[dim].add(value);
            updateURLFromFilters();
        }

        // Reset all filters
        function resetFilters() {
            Object.keys(filterState).forEach(k => filterState[k] = new Set());
            updateURLFromFilters();
            // If we have rawRows, recompute from all rows; else just clear visual filters
            applyFilters(true);
        }

        // Apply filters and animate transitions across charts
        function applyFilters(animate = false) {
            const duration = animate ? 400 : 0;
            const anyFilterActive = Object.values(filterState).some(s => s && s.size && s.size>0);

            // If raw row-level data exists, recompute aggregates based on current filter set
            if (typeof computeAggregatesFromRows === 'function' && window.__rawRows && window.__rawRows.length) {
                const filtered = filterRows(window.__rawRows);
                computeAggregatesFromRows(filtered, true);
                // Recreate charts from new aggregates
                createPieChart();
                createContractChart();
                createTenureChart();
                createPaymentChart();
                createInternetChart();
                createChargesHistogram();
                // Update top-level metrics
                updateTopMetrics(filtered);
                return; // visual updates handled by recreating charts
            }

            // Fallback: no row-level data - perform opacity fades only

            // Pie chart slices opacity by selected status
            d3.select("#pie-chart").selectAll(".pie-slice path")
                .transition().duration(duration)
                .style("opacity", function() {
                    const d = d3.select(this).datum();
                    if (!filterState.status) return 1;
                    return (d.data.label === filterState.status) ? 1 : 0.25;
                })
                .attr("stroke-width", function() {
                    const d = d3.select(this).datum();
                    return (!filterState.status || d.data.label === filterState.status) ? 3 : 1;
                });

            // Contract bars highlight
            d3.select("#bar-chart-contract").selectAll(".bar")
                .transition().duration(duration)
                .style("opacity", function() {
                    const d = d3.select(this).datum();
                    if (!filterState.contract) return 1;
                    return (d.contract === filterState.contract) ? 1 : 0.25;
                })
                .attr("fill", function() {
                    const d = d3.select(this).datum();
                    return healthColor(d.churnRate);
                });

            // Tenure points highlight by selected bucket
            d3.select("#line-chart-tenure").selectAll("circle")
                .transition().duration(duration)
                .style("opacity", function() {
                    const d = d3.select(this).datum();
                    if (!filterState.tenure) return anyFilterActive ? 0.7 : 1;
                    return (d.tenure === filterState.tenure) ? 1 : 0.25;
                })
                .attr("r", function() {
                    const d = d3.select(this).datum();
                    return (!filterState.tenure || d.tenure === filterState.tenure) ? 7 : 5;
                });

            // Payment bars highlight by selected method
            d3.select("#bar-chart-payment").selectAll(".bar")
                .transition().duration(duration)
                .style("opacity", function() {
                    const d = d3.select(this).datum();
                    if (!filterState.payment) return anyFilterActive ? 0.8 : 1;
                    return (d.method === filterState.payment) ? 1 : 0.25;
                });

            // Internet donut segments highlight by selected service
            d3.select("#donut-chart-internet").selectAll("path")
                .transition().duration(duration)
                .style("opacity", function() {
                    const d = d3.select(this).datum();
                    if (!filterState.internet) return anyFilterActive ? 0.85 : 1;
                    return (d.data.service === filterState.internet) ? 1 : 0.25;
                })
                .attr("stroke-width", function() {
                    const d = d3.select(this).datum();
                    return (!filterState.internet || d.data.service === filterState.internet) ? 3 : 1;
                });

            // Monthly charges histogram bars highlight by selected range
            d3.select("#histogram-charges").selectAll(".bar")
                .transition().duration(duration)
                .style("opacity", function() {
                    const d = d3.select(this).datum();
                    if (!filterState.charges) return anyFilterActive ? 0.85 : 1;
                    return (d.range === filterState.charges) ? 1 : 0.25;
                });
        }
        
        // Line chart - Churn by Tenure
        function createTenureChart() {
            const margin = { top: 30, right: 30, bottom: 60, left: 60 };
            const width = 450 - margin.left - margin.right;
            const height = 320 - margin.top - margin.bottom;
            
            // Clear existing content
            d3.select("#line-chart-tenure").selectAll("*").remove();
            
            const svg = d3.select("#line-chart-tenure")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);
            
            const x = d3.scaleBand()
                .domain(churnData.byTenure.map(d => d.tenure))
                .range([0, width])
                .padding(0.1);
            
            const statusFilterActive = filterState.status && filterState.status.size > 0;
            const maxCount = statusFilterActive ? d3.max(churnData.byTenure, d => d.customers) : 55;
            
            const y = d3.scaleLinear()
                .domain([0, statusFilterActive ? maxCount : 55])
                .range([height, 0]);
            
            // X axis
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x));
            
            // X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + 45)
                .attr("text-anchor", "middle")
                .style("fill", "#888")
                .text("Tenure (months)");
            
            // Y axis
            svg.append("g")
                .call(d3.axisLeft(y).tickFormat(d => statusFilterActive ? d : d + "%"));
            
            // Line
            const line = d3.line()
                .x(d => x(d.tenure) + x.bandwidth() / 2)
                .y(d => statusFilterActive ? y(d.customers) : y(d.churnRate))
                .curve(d3.curveMonotoneX);
            
            svg.append("path")
                .datum(churnData.byTenure)
                .attr("fill", "none")
                .attr("stroke", "#00d4ff")
                .attr("stroke-width", 3)
                .attr("d", line);
            
            // Points
            svg.selectAll(".point")
                .data(churnData.byTenure)
                .enter()
                .append("circle")
                .attr("cx", d => x(d.tenure) + x.bandwidth() / 2)
                .attr("cy", d => statusFilterActive ? y(d.customers) : y(d.churnRate))
                .attr("r", 6)
                .attr("fill", "#00d4ff")
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .on("mouseover", function(event, d) {
                    showTooltip(event, `
                        <strong>Tenure: ${d.tenure} months</strong><br/>
                        Churn Rate: ${d.churnRate}%<br/>
                        Customers: ${d.customers.toLocaleString()}
                    `);
                })
                .on("mouseout", hideTooltip)
                .on("click", function(event, d) {
                    toggleSelection('tenure', d.tenure);
                    applyFilters(true);
                });
        }
        
        // Horizontal bar chart - Payment Method
        function createPaymentChart() {
            const margin = { top: 30, right: 30, bottom: 40, left: 120 };
            const width = 450 - margin.left - margin.right;
            const height = 320 - margin.top - margin.bottom;
            
            // Clear existing content
            d3.select("#bar-chart-payment").selectAll("*").remove();
            
            const svg = d3.select("#bar-chart-payment")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);
            
            const y = d3.scaleBand()
                .domain(churnData.byPayment.map(d => d.method))
                .range([0, height])
                .padding(0.3);
            
            const statusFilterActive = filterState.status && filterState.status.size > 0;
            const maxCount = statusFilterActive ? d3.max(churnData.byPayment, d => d.churned + d.retained) : 50;
            
            const x = d3.scaleLinear()
                .domain([0, statusFilterActive ? maxCount : 50])
                .range([0, width]);
            
            // X axis
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x).tickFormat(d => statusFilterActive ? d : d + "%"));
            
            // Y axis
            svg.append("g")
                .call(d3.axisLeft(y));
            
            // Bars
            const colorScale = d3.scaleOrdinal()
                .domain(churnData.byPayment.map(d => d.method))
                .range(["#ff6b6b", "#4ecdc4", "#ffd93d", "#9b59b6"]);
            
            svg.selectAll(".bar")
                .data(churnData.byPayment)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("y", d => y(d.method))
                .attr("x", 0)
                .attr("height", y.bandwidth())
                .attr("width", d => statusFilterActive ? x(d.churned + d.retained) : x(d.churnRate))
                .attr("fill", d => colorScale(d.method))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `
                        <strong>${d.method}</strong><br/>
                        Churn Rate: ${d.churnRate}%<br/>
                        Churned: ${d.churned.toLocaleString()}<br/>
                        Retained: ${d.retained.toLocaleString()}
                    `);
                })
                .on("mouseout", hideTooltip)
                .on("click", function(event, d) {
                    toggleSelection('payment', d.method);
                    applyFilters(true);
                });
            
            // Labels
            svg.selectAll(".label")
                .data(churnData.byPayment)
                .enter()
                .append("text")
                .attr("y", d => y(d.method) + y.bandwidth() / 2 + 4)
                .attr("x", d => statusFilterActive ? x(d.churned + d.retained) + 5 : x(d.churnRate) + 5)
                .style("fill", "#fff")
                .style("font-size", "11px")
                .text(d => statusFilterActive ? (d.churned + d.retained).toLocaleString() : d.churnRate + "%");
        }
        
        // Donut chart - Internet Service
        function createInternetChart() {
            const width = 450;
            const height = 350;
            const radius = Math.min(width, height) / 2 - 40;
            
            // Clear existing content
            d3.select("#donut-chart-internet").selectAll("*").remove();
            
            const svg = d3.select("#donut-chart-internet")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width/2}, ${height/2})`);
            
            const pie = d3.pie()
                .value(d => d.churned + d.retained)
                .sort(null);
            
            const arc = d3.arc()
                .innerRadius(radius * 0.5)
                .outerRadius(radius);
            
            const slices = svg.selectAll(".slice")
                .data(pie(churnData.byInternet))
                .enter()
                .append("g");
            
            slices.append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("stroke", "#1a1a2e")
                .attr("stroke-width", 2)
                .on("mouseover", function(event, d) {
                    const total = d.data.churned + d.data.retained;
                    const churnRate = ((d.data.churned / total) * 100).toFixed(1);
                    showTooltip(event, `
                        <strong>${d.data.service}</strong><br/>
                        Total: ${total.toLocaleString()}<br/>
                        Churned: ${d.data.churned.toLocaleString()}<br/>
                        Churn Rate: ${churnRate}%
                    `);
                })
                .on("mouseout", hideTooltip)
                .on("click", function(event, d) {
                    toggleSelection('internet', d.data.service);
                    applyFilters(true);
                });
            
            // Center text
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "-0.5em")
                .style("fill", "#fff")
                .style("font-size", "14px")
                .text("Internet");
            
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", "1em")
                .style("fill", "#fff")
                .style("font-size", "14px")
                .text("Service");
            
            // Legend
            const legend = svg.selectAll(".legend")
                .data(churnData.byInternet)
                .enter()
                .append("g")
                .attr("transform", (d, i) => `translate(${radius + 30}, ${-40 + i * 30})`);
            
            legend.append("rect")
                .attr("width", 15)
                .attr("height", 15)
                .attr("fill", d => d.color);
            
            legend.append("text")
                .attr("x", 22)
                .attr("y", 12)
                .style("fill", "#aaa")
                .style("font-size", "12px")
                .text(d => d.service);
        }
        
        // Histogram - Monthly Charges
        function createChargesHistogram() {
            const margin = { top: 30, right: 30, bottom: 60, left: 60 };
            const width = 450 - margin.left - margin.right;
            const height = 320 - margin.top - margin.bottom;
            
            // Clear existing content
            d3.select("#histogram-charges").selectAll("*").remove();
            
            const svg = d3.select("#histogram-charges")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);
            
            const x = d3.scaleBand()
                .domain(churnData.monthlyCharges.map(d => d.range))
                .range([0, width])
                .padding(0.2);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(churnData.monthlyCharges, d => d.count)])
                .range([height, 0]);
            
            // X axis
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x));
            
            // X axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + 45)
                .attr("text-anchor", "middle")
                .style("fill", "#888")
                .text("Monthly Charges ($)");
            
            // Y axis
            svg.append("g")
                .call(d3.axisLeft(y));
            
            // Color scale based on churn rate
            const colorScale = d3.scaleLinear()
                .domain([15, 42])
                .range(["#4ecdc4", "#ff6b6b"]);
            
            // Bars
            svg.selectAll(".bar")
                .data(churnData.monthlyCharges)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.range))
                .attr("y", d => y(d.count))
                .attr("width", x.bandwidth())
                .attr("height", d => height - y(d.count))
                .attr("fill", d => colorScale(d.avgChurn))
                .on("mouseover", function(event, d) {
                    showTooltip(event, `
                        <strong>$${d.range}</strong><br/>
                        Customers: ${d.count.toLocaleString()}<br/>
                        Avg Churn Rate: ${d.avgChurn}%
                    `);
                })
                .on("mouseout", hideTooltip)
                .on("click", function(event, d) {
                    filterState.charges = (filterState.charges === d.range) ? null : d.range;
                    applyFilters(true);
                });
            
            // Churn rate annotations
            svg.selectAll(".churn-label")
                .data(churnData.monthlyCharges)
                .enter()
                .append("text")
                .attr("x", d => x(d.range) + x.bandwidth() / 2)
                .attr("y", d => y(d.count) - 5)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-size", "10px")
                .text(d => d.avgChurn + "%");
        }
        
        // Charts are initialized after aggregate CSVs load above.
    </script>
</body>
</html>
